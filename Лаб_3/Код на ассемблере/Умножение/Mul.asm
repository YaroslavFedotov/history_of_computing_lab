SEG1 SEGMENT // Объявление сегмента с именем SEG 1
OPER1 DB 2  // Ввод переменной типа byte со значением 2 и именем OPER1
OPER2 DB 5 //  Ввод переменной типа byte со значением 5 и именем OPER2
RESULT_AREA DW ? // Ввод переменной типа слова со значением ? и именем RESULT_AREA
SEG1 ENDS // Закрытие сегмента с именем SEG1

CODE SEGMENT // Объявление сегмента кода с именем CODE
ASSUME CS:CODE, DS:SEG1 // // Директиву ASSUME CS: требуется указывать в каждой программе, в которой используются стандартные сегментные директивы, так как Ассемблеру необходимо знать о сегменте Кода для того, чтобы установить выполняемую программу. Кроме того, обычно используются директива ASSUME DS благодаря ,которой Ассемблер знает, к каким ячейкам памяти мы можем адресоваться в данный момент. В этом случае мы заносим в сегмент счётчика сегмент кода с названием код и в сегмент данных данные сегмента 1
START: //Запускаем программу
MOV AX,SEG1 //Заносим данные из сегмента с именем SEG1 в регистор аккумулятора
MOV DS,AX // Заносим данные из регистра аккумулятора в сегмент данных

MOV BL,OPER1 // Заносим значение переменной OPER1 в регистор базы низшего порядка
MOV AL,OPER2 // Заносим значение переменной OPER2 в регистор аккумулятора низшего порядка
MUL BL // Производим умножение в базавом регистре низшего порядка
MOV RESULT_AREA,AX // Результат полученный в базавом регистре и занесенный в регистр аккумулятора переносим в переменную RESULT_AREA

MOV AH,4CH // Сложные команды преобразования полученного результата из машинного вида в понятный человеку вид 
INT 21H  // Относится к сложным командам описанно выше
CODE ENDS // Выход из составляющей кода сегмента с именем CODE
END START // Завершаем выполнение программы